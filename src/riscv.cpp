#include "../h/riscv.hpp"
#include "../h/MemoryAlloc.hpp"
#include "../h/Thr.hpp"
#include "../h/Sem.hpp"
#include "../lib/console.h"

// supervisor previous privilege and supervisor previous interrupt enable
// This function can't be inline so that we have the actual call of the function in the assembly generated by compiler.
// We need that call so ra register changes to address that will take us back to threadWrapper function.
void Riscv::popSppSpie()
{
    __asm__ volatile ("csrw sepc, ra");
    __asm__ volatile ("sret");
}

void Riscv::handleSupervisorTrap()
{

    // Read arguments that are passed through registers
    uint64 firstArgument;
    __asm__ volatile ("mv %0, a0" : "=r" (firstArgument));
    uint64 secondArgument;
    __asm__ volatile ("mv %0, a1" : "=r" (secondArgument));
    uint64 thirdArgument;
    __asm__ volatile ("mv %0, a2" : "=r" (thirdArgument));
    uint64 fourthArgument;
    __asm__ volatile ("mv %0, a3" : "=r" (fourthArgument));
    uint64 fifthArgument;
    __asm__ volatile ("mv %0, a4" : "=r" (fifthArgument));

    // Read the cause of interrupt routine entry
    uint64 scause = r_scause();
    if (scause == 0x0000000000000008UL || scause == 0x0000000000000009UL)
    {
        // interrupt: no; cause code: environment call from U-mode(8) or S-mode(9) (ecall instruction)

        // we have to increment sepc for 4 (length of one instruction) because the ecall instruction will set sepc to ecall address instead of next instruction)
        uint64 volatile sepc = r_sepc() + 4;
        uint64 volatile sstatus = r_sstatus();

        // void* mem_alloc (size_t size)
        if (firstArgument == 0x01UL) {
            // call the C++ function that handles allocation
            void *returningPointer = MemoryAlloc::__mem_alloc((size_t) secondArgument);
            // write the returning value in a0. a0 is the 10th element in the stack to which the frame pointer points.
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returningPointer));
        }
            // int mem_free (void*)
        else if (firstArgument == 0x02UL) {
            // call the C++ function that handles deallocation
            int retValue = MemoryAlloc::__mem_free((void*)secondArgument);
            // write the returning value in a0. a0 is the 10th element in the stack to which the frame pointer points.
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (retValue));
        }
            // thread_create (thread_t* handle, void(*start_routine)(void*), void* arg)
        else if (firstArgument == 0x11) {
            // call the C++ function that handles creation of threads
            int returnValue = Thr::createCoroutineStart((Thr **) secondArgument, (Thr::Body) thirdArgument,
                                                        (void *) fourthArgument, (void *) fifthArgument);
            // write the returning value in a0. a0 is the 10th element in the stack to which the frame pointer points.
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
        }
            // thread_exit()
        else if (firstArgument == 0x12) {
            // Call the thread_exit() function in cpp and return the value that confirms that thread is exited correctly
            int returnValue = Thr::running->thread_exit();
            // write the returning value in a0. a0 is the 10th element in the stack to which the frame pointer points.
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
        }
            // thread_dispach()
        else if (firstArgument == 0x13) {
            // synchronous context change
            Thr::yield();
        }
            // thread_join(thread_t handle)
        else if (firstArgument == 0x14) {
            // call the C++ join function
            Thr::running->join((thread_t)secondArgument);
        }
            //sem_open
        else if (firstArgument == 0x21) {
            // call the C++ Sem constructor
            Sem** handle = (sem_t*)(secondArgument);
            *handle = Sem::createSem((Sem**)(secondArgument), (unsigned)thirdArgument);

            uint64 returnValue;
            if(true) {
                returnValue = 0;
                __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
            }
            else {
                returnValue = -1;
                __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
            }
        }
            //sem_close
        else if (firstArgument == 0x22) {
            // call the C++ function for closing the sem

            Sem::closeSem((sem_t)secondArgument);

            uint64 returnValue;
            if((sem_t)secondArgument) {
                returnValue = -1;
                __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
            }
            else {
                returnValue = 0;
                __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
            }
        }
            // sem_wait
        else if (firstArgument == 0x23) {

            uint64 returnValue = ((Sem*)(secondArgument))->wait();
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
        }
            // sem_signal
        else if (firstArgument == 0x24) {

            uint64 returnValue = ((Sem*)(secondArgument))->signal();
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
        }
            // sem_trywait
        else if (firstArgument == 0x26) {

            uint64 returnValue = ((Sem*)(secondArgument))->tryWait();
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
        }
            //time_sleep(time_t)
        else if (firstArgument == 0x31) {
            // Dummy implementation, always returns 0
            uint64 returnValue = 0;
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" (returnValue));
        }
            // getc
        else if (firstArgument == 0x41) {
            char c = __getc();
            __asm__ volatile ("sd %0, 10*8(fp)" : : "r" ((uint64)c));
        }
            // putc
        else if (firstArgument == 0x42) {
            __putc(secondArgument);
        }
        else if (firstArgument == 0x100) {
            // Switch to user mode
            // The SSTATUS_SPP bit indicates previous mode (before we entered the trap routine)
            // it was set to 1 because main is in system mode, but we should force it to 0 to make sure that our
            // code runs in user mode
            __asm__ volatile ("csrc sstatus, %[mask]" : : [mask] "r"((1<<8)));
        }
        else {
            /*
            uint64 volatile sepc = r_sepc() + 4;
            uint64 volatile sstatus = r_sstatus();
            TCB::timeSliceCounter = 0;
            TCB::dispatch();
            w_sstatus(sstatus);
            w_sepc(sepc);
            */
        }
        // We set the return address that we previously saved in sepc (sepc is saved on stack for every thread)
        w_sstatus(sstatus);
        w_sepc(sepc);
    }
    else if (scause == 0x8000000000000001UL)
    {
        // interrupt: yes; cause code: supervisor software interrupt (CLINT; machine timer interrupt)
        // mc_sip (mask clear supervisor interrupt pending register). We call this so we signal that we handled the exception
        mc_sip(SIP_SSIP);
//        // Everytime timer interrupts us we increment the timeSliceCounter for running thread
//        TCB::timeSliceCounter++;
//        if (TCB::timeSliceCounter >= TCB::running->getTimeSlice())
//        {
//            // If the timeslice is bigger than counter, we dispatch (switch context)
//            // First we save current sepc(supervisor exception pc) and current sstatus of the thread
//            // We do this because the return address from trap routine isn't saved in RA register, but sepc register instead.
//            uint64 volatile sepc = r_sepc();
//            uint64 volatile sstatus = r_sstatus();
//            // We reset its counter for the next time she runs
//            TCB::timeSliceCounter = 0;
//            // Switch context
//            TCB::yield();
//            // We set the return address that we previously saved in sepc (sepc is saved on stack for every thread)
//            w_sstatus(sstatus);
//            w_sepc(sepc);
//        }
    }
    else if (scause == 0x8000000000000009UL)
    {
        console_handler();
    }
    else
    {
        // unexpected trap cause
        printString("scause: ");
        printInt(r_scause());
        printString("\nsepc: ");
        printInt(r_sepc());
        printString("\nstval: ");
        printInt(r_stval());
        thread_exit();
    }
}